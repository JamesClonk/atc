// This file was generated by counterfeiter
package workerfakes

import (
	"os"
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/dbng"
	"github.com/concourse/atc/worker"
)

type FakeWorker struct {
	FindOrCreateBuildContainerStub        func(lager.Logger, <-chan os.Signal, worker.ImageFetchingDelegate, worker.Identifier, worker.Metadata, worker.ContainerSpec, atc.ResourceTypes, map[string]string) (worker.Container, error)
	findOrCreateBuildContainerMutex       sync.RWMutex
	findOrCreateBuildContainerArgsForCall []struct {
		arg1 lager.Logger
		arg2 <-chan os.Signal
		arg3 worker.ImageFetchingDelegate
		arg4 worker.Identifier
		arg5 worker.Metadata
		arg6 worker.ContainerSpec
		arg7 atc.ResourceTypes
		arg8 map[string]string
	}
	findOrCreateBuildContainerReturns struct {
		result1 worker.Container
		result2 error
	}
	FindOrCreateResourceGetContainerStub        func(logger lager.Logger, cancel <-chan os.Signal, delegate worker.ImageFetchingDelegate, id worker.Identifier, metadata worker.Metadata, spec worker.ContainerSpec, resourceTypes atc.ResourceTypes, outputPaths map[string]string, resourceType string, version atc.Version, source atc.Source, params atc.Params) (worker.Container, error)
	findOrCreateResourceGetContainerMutex       sync.RWMutex
	findOrCreateResourceGetContainerArgsForCall []struct {
		logger        lager.Logger
		cancel        <-chan os.Signal
		delegate      worker.ImageFetchingDelegate
		id            worker.Identifier
		metadata      worker.Metadata
		spec          worker.ContainerSpec
		resourceTypes atc.ResourceTypes
		outputPaths   map[string]string
		resourceType  string
		version       atc.Version
		source        atc.Source
		params        atc.Params
	}
	findOrCreateResourceGetContainerReturns struct {
		result1 worker.Container
		result2 error
	}
	FindOrCreateResourceCheckContainerStub        func(logger lager.Logger, cancel <-chan os.Signal, delegate worker.ImageFetchingDelegate, id worker.Identifier, metadata worker.Metadata, spec worker.ContainerSpec, resourceTypes atc.ResourceTypes, resourceType string, source atc.Source) (worker.Container, error)
	findOrCreateResourceCheckContainerMutex       sync.RWMutex
	findOrCreateResourceCheckContainerArgsForCall []struct {
		logger        lager.Logger
		cancel        <-chan os.Signal
		delegate      worker.ImageFetchingDelegate
		id            worker.Identifier
		metadata      worker.Metadata
		spec          worker.ContainerSpec
		resourceTypes atc.ResourceTypes
		resourceType  string
		source        atc.Source
	}
	findOrCreateResourceCheckContainerReturns struct {
		result1 worker.Container
		result2 error
	}
	FindOrCreateResourceTypeCheckContainerStub        func(logger lager.Logger, cancel <-chan os.Signal, delegate worker.ImageFetchingDelegate, id worker.Identifier, metadata worker.Metadata, spec worker.ContainerSpec, resourceTypes atc.ResourceTypes, resourceType string, source atc.Source) (worker.Container, error)
	findOrCreateResourceTypeCheckContainerMutex       sync.RWMutex
	findOrCreateResourceTypeCheckContainerArgsForCall []struct {
		logger        lager.Logger
		cancel        <-chan os.Signal
		delegate      worker.ImageFetchingDelegate
		id            worker.Identifier
		metadata      worker.Metadata
		spec          worker.ContainerSpec
		resourceTypes atc.ResourceTypes
		resourceType  string
		source        atc.Source
	}
	findOrCreateResourceTypeCheckContainerReturns struct {
		result1 worker.Container
		result2 error
	}
	FindOrCreateContainerForIdentifierStub        func(logger lager.Logger, id worker.Identifier, metadata worker.Metadata, containerSpec worker.ContainerSpec, resourceTypes atc.ResourceTypes, imageFetchingDelegate worker.ImageFetchingDelegate, resourceSources map[string]worker.ArtifactSource) (worker.Container, []string, error)
	findOrCreateContainerForIdentifierMutex       sync.RWMutex
	findOrCreateContainerForIdentifierArgsForCall []struct {
		logger                lager.Logger
		id                    worker.Identifier
		metadata              worker.Metadata
		containerSpec         worker.ContainerSpec
		resourceTypes         atc.ResourceTypes
		imageFetchingDelegate worker.ImageFetchingDelegate
		resourceSources       map[string]worker.ArtifactSource
	}
	findOrCreateContainerForIdentifierReturns struct {
		result1 worker.Container
		result2 []string
		result3 error
	}
	FindOrCreateVolumeForResourceCacheStub        func(logger lager.Logger, vs worker.VolumeSpec, resourceCache *dbng.UsedResourceCache) (worker.Volume, error)
	findOrCreateVolumeForResourceCacheMutex       sync.RWMutex
	findOrCreateVolumeForResourceCacheArgsForCall []struct {
		logger        lager.Logger
		vs            worker.VolumeSpec
		resourceCache *dbng.UsedResourceCache
	}
	findOrCreateVolumeForResourceCacheReturns struct {
		result1 worker.Volume
		result2 error
	}
	FindInitializedVolumeForResourceCacheStub        func(logger lager.Logger, resourceCache *dbng.UsedResourceCache) (worker.Volume, bool, error)
	findInitializedVolumeForResourceCacheMutex       sync.RWMutex
	findInitializedVolumeForResourceCacheArgsForCall []struct {
		logger        lager.Logger
		resourceCache *dbng.UsedResourceCache
	}
	findInitializedVolumeForResourceCacheReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	FindContainerForIdentifierStub        func(lager.Logger, worker.Identifier) (worker.Container, bool, error)
	findContainerForIdentifierMutex       sync.RWMutex
	findContainerForIdentifierArgsForCall []struct {
		arg1 lager.Logger
		arg2 worker.Identifier
	}
	findContainerForIdentifierReturns struct {
		result1 worker.Container
		result2 bool
		result3 error
	}
	FindContainerByHandleStub        func(lager.Logger, string, int) (worker.Container, bool, error)
	findContainerByHandleMutex       sync.RWMutex
	findContainerByHandleArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 int
	}
	findContainerByHandleReturns struct {
		result1 worker.Container
		result2 bool
		result3 error
	}
	ValidateResourceCheckVersionStub        func(container db.SavedContainer) (bool, error)
	validateResourceCheckVersionMutex       sync.RWMutex
	validateResourceCheckVersionArgsForCall []struct {
		container db.SavedContainer
	}
	validateResourceCheckVersionReturns struct {
		result1 bool
		result2 error
	}
	FindResourceTypeByPathStub        func(path string) (atc.WorkerResourceType, bool)
	findResourceTypeByPathMutex       sync.RWMutex
	findResourceTypeByPathArgsForCall []struct {
		path string
	}
	findResourceTypeByPathReturns struct {
		result1 atc.WorkerResourceType
		result2 bool
	}
	LookupVolumeStub        func(lager.Logger, string) (worker.Volume, bool, error)
	lookupVolumeMutex       sync.RWMutex
	lookupVolumeArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	lookupVolumeReturns struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}
	SatisfyingStub        func(worker.WorkerSpec, atc.ResourceTypes) (worker.Worker, error)
	satisfyingMutex       sync.RWMutex
	satisfyingArgsForCall []struct {
		arg1 worker.WorkerSpec
		arg2 atc.ResourceTypes
	}
	satisfyingReturns struct {
		result1 worker.Worker
		result2 error
	}
	AllSatisfyingStub        func(worker.WorkerSpec, atc.ResourceTypes) ([]worker.Worker, error)
	allSatisfyingMutex       sync.RWMutex
	allSatisfyingArgsForCall []struct {
		arg1 worker.WorkerSpec
		arg2 atc.ResourceTypes
	}
	allSatisfyingReturns struct {
		result1 []worker.Worker
		result2 error
	}
	RunningWorkersStub        func() ([]worker.Worker, error)
	runningWorkersMutex       sync.RWMutex
	runningWorkersArgsForCall []struct{}
	runningWorkersReturns     struct {
		result1 []worker.Worker
		result2 error
	}
	GetWorkerStub        func(workerName string) (worker.Worker, error)
	getWorkerMutex       sync.RWMutex
	getWorkerArgsForCall []struct {
		workerName string
	}
	getWorkerReturns struct {
		result1 worker.Worker
		result2 error
	}
	ActiveContainersStub        func() int
	activeContainersMutex       sync.RWMutex
	activeContainersArgsForCall []struct{}
	activeContainersReturns     struct {
		result1 int
	}
	DescriptionStub        func() string
	descriptionMutex       sync.RWMutex
	descriptionArgsForCall []struct{}
	descriptionReturns     struct {
		result1 string
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	AddressStub        func() *string
	addressMutex       sync.RWMutex
	addressArgsForCall []struct{}
	addressReturns     struct {
		result1 *string
	}
	ResourceTypesStub        func() []atc.WorkerResourceType
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct{}
	resourceTypesReturns     struct {
		result1 []atc.WorkerResourceType
	}
	TagsStub        func() atc.Tags
	tagsMutex       sync.RWMutex
	tagsArgsForCall []struct{}
	tagsReturns     struct {
		result1 atc.Tags
	}
	UptimeStub        func() time.Duration
	uptimeMutex       sync.RWMutex
	uptimeArgsForCall []struct{}
	uptimeReturns     struct {
		result1 time.Duration
	}
	IsOwnedByTeamStub        func() bool
	isOwnedByTeamMutex       sync.RWMutex
	isOwnedByTeamArgsForCall []struct{}
	isOwnedByTeamReturns     struct {
		result1 bool
	}
	IsVersionCompatibleStub        func() bool
	isVersionCompatibleMutex       sync.RWMutex
	isVersionCompatibleArgsForCall []struct{}
	isVersionCompatibleReturns     struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorker) FindOrCreateBuildContainer(arg1 lager.Logger, arg2 <-chan os.Signal, arg3 worker.ImageFetchingDelegate, arg4 worker.Identifier, arg5 worker.Metadata, arg6 worker.ContainerSpec, arg7 atc.ResourceTypes, arg8 map[string]string) (worker.Container, error) {
	fake.findOrCreateBuildContainerMutex.Lock()
	fake.findOrCreateBuildContainerArgsForCall = append(fake.findOrCreateBuildContainerArgsForCall, struct {
		arg1 lager.Logger
		arg2 <-chan os.Signal
		arg3 worker.ImageFetchingDelegate
		arg4 worker.Identifier
		arg5 worker.Metadata
		arg6 worker.ContainerSpec
		arg7 atc.ResourceTypes
		arg8 map[string]string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	fake.recordInvocation("FindOrCreateBuildContainer", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8})
	fake.findOrCreateBuildContainerMutex.Unlock()
	if fake.FindOrCreateBuildContainerStub != nil {
		return fake.FindOrCreateBuildContainerStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	} else {
		return fake.findOrCreateBuildContainerReturns.result1, fake.findOrCreateBuildContainerReturns.result2
	}
}

func (fake *FakeWorker) FindOrCreateBuildContainerCallCount() int {
	fake.findOrCreateBuildContainerMutex.RLock()
	defer fake.findOrCreateBuildContainerMutex.RUnlock()
	return len(fake.findOrCreateBuildContainerArgsForCall)
}

func (fake *FakeWorker) FindOrCreateBuildContainerArgsForCall(i int) (lager.Logger, <-chan os.Signal, worker.ImageFetchingDelegate, worker.Identifier, worker.Metadata, worker.ContainerSpec, atc.ResourceTypes, map[string]string) {
	fake.findOrCreateBuildContainerMutex.RLock()
	defer fake.findOrCreateBuildContainerMutex.RUnlock()
	return fake.findOrCreateBuildContainerArgsForCall[i].arg1, fake.findOrCreateBuildContainerArgsForCall[i].arg2, fake.findOrCreateBuildContainerArgsForCall[i].arg3, fake.findOrCreateBuildContainerArgsForCall[i].arg4, fake.findOrCreateBuildContainerArgsForCall[i].arg5, fake.findOrCreateBuildContainerArgsForCall[i].arg6, fake.findOrCreateBuildContainerArgsForCall[i].arg7, fake.findOrCreateBuildContainerArgsForCall[i].arg8
}

func (fake *FakeWorker) FindOrCreateBuildContainerReturns(result1 worker.Container, result2 error) {
	fake.FindOrCreateBuildContainerStub = nil
	fake.findOrCreateBuildContainerReturns = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindOrCreateResourceGetContainer(logger lager.Logger, cancel <-chan os.Signal, delegate worker.ImageFetchingDelegate, id worker.Identifier, metadata worker.Metadata, spec worker.ContainerSpec, resourceTypes atc.ResourceTypes, outputPaths map[string]string, resourceType string, version atc.Version, source atc.Source, params atc.Params) (worker.Container, error) {
	fake.findOrCreateResourceGetContainerMutex.Lock()
	fake.findOrCreateResourceGetContainerArgsForCall = append(fake.findOrCreateResourceGetContainerArgsForCall, struct {
		logger        lager.Logger
		cancel        <-chan os.Signal
		delegate      worker.ImageFetchingDelegate
		id            worker.Identifier
		metadata      worker.Metadata
		spec          worker.ContainerSpec
		resourceTypes atc.ResourceTypes
		outputPaths   map[string]string
		resourceType  string
		version       atc.Version
		source        atc.Source
		params        atc.Params
	}{logger, cancel, delegate, id, metadata, spec, resourceTypes, outputPaths, resourceType, version, source, params})
	fake.recordInvocation("FindOrCreateResourceGetContainer", []interface{}{logger, cancel, delegate, id, metadata, spec, resourceTypes, outputPaths, resourceType, version, source, params})
	fake.findOrCreateResourceGetContainerMutex.Unlock()
	if fake.FindOrCreateResourceGetContainerStub != nil {
		return fake.FindOrCreateResourceGetContainerStub(logger, cancel, delegate, id, metadata, spec, resourceTypes, outputPaths, resourceType, version, source, params)
	} else {
		return fake.findOrCreateResourceGetContainerReturns.result1, fake.findOrCreateResourceGetContainerReturns.result2
	}
}

func (fake *FakeWorker) FindOrCreateResourceGetContainerCallCount() int {
	fake.findOrCreateResourceGetContainerMutex.RLock()
	defer fake.findOrCreateResourceGetContainerMutex.RUnlock()
	return len(fake.findOrCreateResourceGetContainerArgsForCall)
}

func (fake *FakeWorker) FindOrCreateResourceGetContainerArgsForCall(i int) (lager.Logger, <-chan os.Signal, worker.ImageFetchingDelegate, worker.Identifier, worker.Metadata, worker.ContainerSpec, atc.ResourceTypes, map[string]string, string, atc.Version, atc.Source, atc.Params) {
	fake.findOrCreateResourceGetContainerMutex.RLock()
	defer fake.findOrCreateResourceGetContainerMutex.RUnlock()
	return fake.findOrCreateResourceGetContainerArgsForCall[i].logger, fake.findOrCreateResourceGetContainerArgsForCall[i].cancel, fake.findOrCreateResourceGetContainerArgsForCall[i].delegate, fake.findOrCreateResourceGetContainerArgsForCall[i].id, fake.findOrCreateResourceGetContainerArgsForCall[i].metadata, fake.findOrCreateResourceGetContainerArgsForCall[i].spec, fake.findOrCreateResourceGetContainerArgsForCall[i].resourceTypes, fake.findOrCreateResourceGetContainerArgsForCall[i].outputPaths, fake.findOrCreateResourceGetContainerArgsForCall[i].resourceType, fake.findOrCreateResourceGetContainerArgsForCall[i].version, fake.findOrCreateResourceGetContainerArgsForCall[i].source, fake.findOrCreateResourceGetContainerArgsForCall[i].params
}

func (fake *FakeWorker) FindOrCreateResourceGetContainerReturns(result1 worker.Container, result2 error) {
	fake.FindOrCreateResourceGetContainerStub = nil
	fake.findOrCreateResourceGetContainerReturns = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindOrCreateResourceCheckContainer(logger lager.Logger, cancel <-chan os.Signal, delegate worker.ImageFetchingDelegate, id worker.Identifier, metadata worker.Metadata, spec worker.ContainerSpec, resourceTypes atc.ResourceTypes, resourceType string, source atc.Source) (worker.Container, error) {
	fake.findOrCreateResourceCheckContainerMutex.Lock()
	fake.findOrCreateResourceCheckContainerArgsForCall = append(fake.findOrCreateResourceCheckContainerArgsForCall, struct {
		logger        lager.Logger
		cancel        <-chan os.Signal
		delegate      worker.ImageFetchingDelegate
		id            worker.Identifier
		metadata      worker.Metadata
		spec          worker.ContainerSpec
		resourceTypes atc.ResourceTypes
		resourceType  string
		source        atc.Source
	}{logger, cancel, delegate, id, metadata, spec, resourceTypes, resourceType, source})
	fake.recordInvocation("FindOrCreateResourceCheckContainer", []interface{}{logger, cancel, delegate, id, metadata, spec, resourceTypes, resourceType, source})
	fake.findOrCreateResourceCheckContainerMutex.Unlock()
	if fake.FindOrCreateResourceCheckContainerStub != nil {
		return fake.FindOrCreateResourceCheckContainerStub(logger, cancel, delegate, id, metadata, spec, resourceTypes, resourceType, source)
	} else {
		return fake.findOrCreateResourceCheckContainerReturns.result1, fake.findOrCreateResourceCheckContainerReturns.result2
	}
}

func (fake *FakeWorker) FindOrCreateResourceCheckContainerCallCount() int {
	fake.findOrCreateResourceCheckContainerMutex.RLock()
	defer fake.findOrCreateResourceCheckContainerMutex.RUnlock()
	return len(fake.findOrCreateResourceCheckContainerArgsForCall)
}

func (fake *FakeWorker) FindOrCreateResourceCheckContainerArgsForCall(i int) (lager.Logger, <-chan os.Signal, worker.ImageFetchingDelegate, worker.Identifier, worker.Metadata, worker.ContainerSpec, atc.ResourceTypes, string, atc.Source) {
	fake.findOrCreateResourceCheckContainerMutex.RLock()
	defer fake.findOrCreateResourceCheckContainerMutex.RUnlock()
	return fake.findOrCreateResourceCheckContainerArgsForCall[i].logger, fake.findOrCreateResourceCheckContainerArgsForCall[i].cancel, fake.findOrCreateResourceCheckContainerArgsForCall[i].delegate, fake.findOrCreateResourceCheckContainerArgsForCall[i].id, fake.findOrCreateResourceCheckContainerArgsForCall[i].metadata, fake.findOrCreateResourceCheckContainerArgsForCall[i].spec, fake.findOrCreateResourceCheckContainerArgsForCall[i].resourceTypes, fake.findOrCreateResourceCheckContainerArgsForCall[i].resourceType, fake.findOrCreateResourceCheckContainerArgsForCall[i].source
}

func (fake *FakeWorker) FindOrCreateResourceCheckContainerReturns(result1 worker.Container, result2 error) {
	fake.FindOrCreateResourceCheckContainerStub = nil
	fake.findOrCreateResourceCheckContainerReturns = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindOrCreateResourceTypeCheckContainer(logger lager.Logger, cancel <-chan os.Signal, delegate worker.ImageFetchingDelegate, id worker.Identifier, metadata worker.Metadata, spec worker.ContainerSpec, resourceTypes atc.ResourceTypes, resourceType string, source atc.Source) (worker.Container, error) {
	fake.findOrCreateResourceTypeCheckContainerMutex.Lock()
	fake.findOrCreateResourceTypeCheckContainerArgsForCall = append(fake.findOrCreateResourceTypeCheckContainerArgsForCall, struct {
		logger        lager.Logger
		cancel        <-chan os.Signal
		delegate      worker.ImageFetchingDelegate
		id            worker.Identifier
		metadata      worker.Metadata
		spec          worker.ContainerSpec
		resourceTypes atc.ResourceTypes
		resourceType  string
		source        atc.Source
	}{logger, cancel, delegate, id, metadata, spec, resourceTypes, resourceType, source})
	fake.recordInvocation("FindOrCreateResourceTypeCheckContainer", []interface{}{logger, cancel, delegate, id, metadata, spec, resourceTypes, resourceType, source})
	fake.findOrCreateResourceTypeCheckContainerMutex.Unlock()
	if fake.FindOrCreateResourceTypeCheckContainerStub != nil {
		return fake.FindOrCreateResourceTypeCheckContainerStub(logger, cancel, delegate, id, metadata, spec, resourceTypes, resourceType, source)
	} else {
		return fake.findOrCreateResourceTypeCheckContainerReturns.result1, fake.findOrCreateResourceTypeCheckContainerReturns.result2
	}
}

func (fake *FakeWorker) FindOrCreateResourceTypeCheckContainerCallCount() int {
	fake.findOrCreateResourceTypeCheckContainerMutex.RLock()
	defer fake.findOrCreateResourceTypeCheckContainerMutex.RUnlock()
	return len(fake.findOrCreateResourceTypeCheckContainerArgsForCall)
}

func (fake *FakeWorker) FindOrCreateResourceTypeCheckContainerArgsForCall(i int) (lager.Logger, <-chan os.Signal, worker.ImageFetchingDelegate, worker.Identifier, worker.Metadata, worker.ContainerSpec, atc.ResourceTypes, string, atc.Source) {
	fake.findOrCreateResourceTypeCheckContainerMutex.RLock()
	defer fake.findOrCreateResourceTypeCheckContainerMutex.RUnlock()
	return fake.findOrCreateResourceTypeCheckContainerArgsForCall[i].logger, fake.findOrCreateResourceTypeCheckContainerArgsForCall[i].cancel, fake.findOrCreateResourceTypeCheckContainerArgsForCall[i].delegate, fake.findOrCreateResourceTypeCheckContainerArgsForCall[i].id, fake.findOrCreateResourceTypeCheckContainerArgsForCall[i].metadata, fake.findOrCreateResourceTypeCheckContainerArgsForCall[i].spec, fake.findOrCreateResourceTypeCheckContainerArgsForCall[i].resourceTypes, fake.findOrCreateResourceTypeCheckContainerArgsForCall[i].resourceType, fake.findOrCreateResourceTypeCheckContainerArgsForCall[i].source
}

func (fake *FakeWorker) FindOrCreateResourceTypeCheckContainerReturns(result1 worker.Container, result2 error) {
	fake.FindOrCreateResourceTypeCheckContainerStub = nil
	fake.findOrCreateResourceTypeCheckContainerReturns = struct {
		result1 worker.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindOrCreateContainerForIdentifier(logger lager.Logger, id worker.Identifier, metadata worker.Metadata, containerSpec worker.ContainerSpec, resourceTypes atc.ResourceTypes, imageFetchingDelegate worker.ImageFetchingDelegate, resourceSources map[string]worker.ArtifactSource) (worker.Container, []string, error) {
	fake.findOrCreateContainerForIdentifierMutex.Lock()
	fake.findOrCreateContainerForIdentifierArgsForCall = append(fake.findOrCreateContainerForIdentifierArgsForCall, struct {
		logger                lager.Logger
		id                    worker.Identifier
		metadata              worker.Metadata
		containerSpec         worker.ContainerSpec
		resourceTypes         atc.ResourceTypes
		imageFetchingDelegate worker.ImageFetchingDelegate
		resourceSources       map[string]worker.ArtifactSource
	}{logger, id, metadata, containerSpec, resourceTypes, imageFetchingDelegate, resourceSources})
	fake.recordInvocation("FindOrCreateContainerForIdentifier", []interface{}{logger, id, metadata, containerSpec, resourceTypes, imageFetchingDelegate, resourceSources})
	fake.findOrCreateContainerForIdentifierMutex.Unlock()
	if fake.FindOrCreateContainerForIdentifierStub != nil {
		return fake.FindOrCreateContainerForIdentifierStub(logger, id, metadata, containerSpec, resourceTypes, imageFetchingDelegate, resourceSources)
	} else {
		return fake.findOrCreateContainerForIdentifierReturns.result1, fake.findOrCreateContainerForIdentifierReturns.result2, fake.findOrCreateContainerForIdentifierReturns.result3
	}
}

func (fake *FakeWorker) FindOrCreateContainerForIdentifierCallCount() int {
	fake.findOrCreateContainerForIdentifierMutex.RLock()
	defer fake.findOrCreateContainerForIdentifierMutex.RUnlock()
	return len(fake.findOrCreateContainerForIdentifierArgsForCall)
}

func (fake *FakeWorker) FindOrCreateContainerForIdentifierArgsForCall(i int) (lager.Logger, worker.Identifier, worker.Metadata, worker.ContainerSpec, atc.ResourceTypes, worker.ImageFetchingDelegate, map[string]worker.ArtifactSource) {
	fake.findOrCreateContainerForIdentifierMutex.RLock()
	defer fake.findOrCreateContainerForIdentifierMutex.RUnlock()
	return fake.findOrCreateContainerForIdentifierArgsForCall[i].logger, fake.findOrCreateContainerForIdentifierArgsForCall[i].id, fake.findOrCreateContainerForIdentifierArgsForCall[i].metadata, fake.findOrCreateContainerForIdentifierArgsForCall[i].containerSpec, fake.findOrCreateContainerForIdentifierArgsForCall[i].resourceTypes, fake.findOrCreateContainerForIdentifierArgsForCall[i].imageFetchingDelegate, fake.findOrCreateContainerForIdentifierArgsForCall[i].resourceSources
}

func (fake *FakeWorker) FindOrCreateContainerForIdentifierReturns(result1 worker.Container, result2 []string, result3 error) {
	fake.FindOrCreateContainerForIdentifierStub = nil
	fake.findOrCreateContainerForIdentifierReturns = struct {
		result1 worker.Container
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindOrCreateVolumeForResourceCache(logger lager.Logger, vs worker.VolumeSpec, resourceCache *dbng.UsedResourceCache) (worker.Volume, error) {
	fake.findOrCreateVolumeForResourceCacheMutex.Lock()
	fake.findOrCreateVolumeForResourceCacheArgsForCall = append(fake.findOrCreateVolumeForResourceCacheArgsForCall, struct {
		logger        lager.Logger
		vs            worker.VolumeSpec
		resourceCache *dbng.UsedResourceCache
	}{logger, vs, resourceCache})
	fake.recordInvocation("FindOrCreateVolumeForResourceCache", []interface{}{logger, vs, resourceCache})
	fake.findOrCreateVolumeForResourceCacheMutex.Unlock()
	if fake.FindOrCreateVolumeForResourceCacheStub != nil {
		return fake.FindOrCreateVolumeForResourceCacheStub(logger, vs, resourceCache)
	} else {
		return fake.findOrCreateVolumeForResourceCacheReturns.result1, fake.findOrCreateVolumeForResourceCacheReturns.result2
	}
}

func (fake *FakeWorker) FindOrCreateVolumeForResourceCacheCallCount() int {
	fake.findOrCreateVolumeForResourceCacheMutex.RLock()
	defer fake.findOrCreateVolumeForResourceCacheMutex.RUnlock()
	return len(fake.findOrCreateVolumeForResourceCacheArgsForCall)
}

func (fake *FakeWorker) FindOrCreateVolumeForResourceCacheArgsForCall(i int) (lager.Logger, worker.VolumeSpec, *dbng.UsedResourceCache) {
	fake.findOrCreateVolumeForResourceCacheMutex.RLock()
	defer fake.findOrCreateVolumeForResourceCacheMutex.RUnlock()
	return fake.findOrCreateVolumeForResourceCacheArgsForCall[i].logger, fake.findOrCreateVolumeForResourceCacheArgsForCall[i].vs, fake.findOrCreateVolumeForResourceCacheArgsForCall[i].resourceCache
}

func (fake *FakeWorker) FindOrCreateVolumeForResourceCacheReturns(result1 worker.Volume, result2 error) {
	fake.FindOrCreateVolumeForResourceCacheStub = nil
	fake.findOrCreateVolumeForResourceCacheReturns = struct {
		result1 worker.Volume
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindInitializedVolumeForResourceCache(logger lager.Logger, resourceCache *dbng.UsedResourceCache) (worker.Volume, bool, error) {
	fake.findInitializedVolumeForResourceCacheMutex.Lock()
	fake.findInitializedVolumeForResourceCacheArgsForCall = append(fake.findInitializedVolumeForResourceCacheArgsForCall, struct {
		logger        lager.Logger
		resourceCache *dbng.UsedResourceCache
	}{logger, resourceCache})
	fake.recordInvocation("FindInitializedVolumeForResourceCache", []interface{}{logger, resourceCache})
	fake.findInitializedVolumeForResourceCacheMutex.Unlock()
	if fake.FindInitializedVolumeForResourceCacheStub != nil {
		return fake.FindInitializedVolumeForResourceCacheStub(logger, resourceCache)
	} else {
		return fake.findInitializedVolumeForResourceCacheReturns.result1, fake.findInitializedVolumeForResourceCacheReturns.result2, fake.findInitializedVolumeForResourceCacheReturns.result3
	}
}

func (fake *FakeWorker) FindInitializedVolumeForResourceCacheCallCount() int {
	fake.findInitializedVolumeForResourceCacheMutex.RLock()
	defer fake.findInitializedVolumeForResourceCacheMutex.RUnlock()
	return len(fake.findInitializedVolumeForResourceCacheArgsForCall)
}

func (fake *FakeWorker) FindInitializedVolumeForResourceCacheArgsForCall(i int) (lager.Logger, *dbng.UsedResourceCache) {
	fake.findInitializedVolumeForResourceCacheMutex.RLock()
	defer fake.findInitializedVolumeForResourceCacheMutex.RUnlock()
	return fake.findInitializedVolumeForResourceCacheArgsForCall[i].logger, fake.findInitializedVolumeForResourceCacheArgsForCall[i].resourceCache
}

func (fake *FakeWorker) FindInitializedVolumeForResourceCacheReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.FindInitializedVolumeForResourceCacheStub = nil
	fake.findInitializedVolumeForResourceCacheReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindContainerForIdentifier(arg1 lager.Logger, arg2 worker.Identifier) (worker.Container, bool, error) {
	fake.findContainerForIdentifierMutex.Lock()
	fake.findContainerForIdentifierArgsForCall = append(fake.findContainerForIdentifierArgsForCall, struct {
		arg1 lager.Logger
		arg2 worker.Identifier
	}{arg1, arg2})
	fake.recordInvocation("FindContainerForIdentifier", []interface{}{arg1, arg2})
	fake.findContainerForIdentifierMutex.Unlock()
	if fake.FindContainerForIdentifierStub != nil {
		return fake.FindContainerForIdentifierStub(arg1, arg2)
	} else {
		return fake.findContainerForIdentifierReturns.result1, fake.findContainerForIdentifierReturns.result2, fake.findContainerForIdentifierReturns.result3
	}
}

func (fake *FakeWorker) FindContainerForIdentifierCallCount() int {
	fake.findContainerForIdentifierMutex.RLock()
	defer fake.findContainerForIdentifierMutex.RUnlock()
	return len(fake.findContainerForIdentifierArgsForCall)
}

func (fake *FakeWorker) FindContainerForIdentifierArgsForCall(i int) (lager.Logger, worker.Identifier) {
	fake.findContainerForIdentifierMutex.RLock()
	defer fake.findContainerForIdentifierMutex.RUnlock()
	return fake.findContainerForIdentifierArgsForCall[i].arg1, fake.findContainerForIdentifierArgsForCall[i].arg2
}

func (fake *FakeWorker) FindContainerForIdentifierReturns(result1 worker.Container, result2 bool, result3 error) {
	fake.FindContainerForIdentifierStub = nil
	fake.findContainerForIdentifierReturns = struct {
		result1 worker.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindContainerByHandle(arg1 lager.Logger, arg2 string, arg3 int) (worker.Container, bool, error) {
	fake.findContainerByHandleMutex.Lock()
	fake.findContainerByHandleArgsForCall = append(fake.findContainerByHandleArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("FindContainerByHandle", []interface{}{arg1, arg2, arg3})
	fake.findContainerByHandleMutex.Unlock()
	if fake.FindContainerByHandleStub != nil {
		return fake.FindContainerByHandleStub(arg1, arg2, arg3)
	} else {
		return fake.findContainerByHandleReturns.result1, fake.findContainerByHandleReturns.result2, fake.findContainerByHandleReturns.result3
	}
}

func (fake *FakeWorker) FindContainerByHandleCallCount() int {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	return len(fake.findContainerByHandleArgsForCall)
}

func (fake *FakeWorker) FindContainerByHandleArgsForCall(i int) (lager.Logger, string, int) {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	return fake.findContainerByHandleArgsForCall[i].arg1, fake.findContainerByHandleArgsForCall[i].arg2, fake.findContainerByHandleArgsForCall[i].arg3
}

func (fake *FakeWorker) FindContainerByHandleReturns(result1 worker.Container, result2 bool, result3 error) {
	fake.FindContainerByHandleStub = nil
	fake.findContainerByHandleReturns = struct {
		result1 worker.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) ValidateResourceCheckVersion(container db.SavedContainer) (bool, error) {
	fake.validateResourceCheckVersionMutex.Lock()
	fake.validateResourceCheckVersionArgsForCall = append(fake.validateResourceCheckVersionArgsForCall, struct {
		container db.SavedContainer
	}{container})
	fake.recordInvocation("ValidateResourceCheckVersion", []interface{}{container})
	fake.validateResourceCheckVersionMutex.Unlock()
	if fake.ValidateResourceCheckVersionStub != nil {
		return fake.ValidateResourceCheckVersionStub(container)
	} else {
		return fake.validateResourceCheckVersionReturns.result1, fake.validateResourceCheckVersionReturns.result2
	}
}

func (fake *FakeWorker) ValidateResourceCheckVersionCallCount() int {
	fake.validateResourceCheckVersionMutex.RLock()
	defer fake.validateResourceCheckVersionMutex.RUnlock()
	return len(fake.validateResourceCheckVersionArgsForCall)
}

func (fake *FakeWorker) ValidateResourceCheckVersionArgsForCall(i int) db.SavedContainer {
	fake.validateResourceCheckVersionMutex.RLock()
	defer fake.validateResourceCheckVersionMutex.RUnlock()
	return fake.validateResourceCheckVersionArgsForCall[i].container
}

func (fake *FakeWorker) ValidateResourceCheckVersionReturns(result1 bool, result2 error) {
	fake.ValidateResourceCheckVersionStub = nil
	fake.validateResourceCheckVersionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) FindResourceTypeByPath(path string) (atc.WorkerResourceType, bool) {
	fake.findResourceTypeByPathMutex.Lock()
	fake.findResourceTypeByPathArgsForCall = append(fake.findResourceTypeByPathArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("FindResourceTypeByPath", []interface{}{path})
	fake.findResourceTypeByPathMutex.Unlock()
	if fake.FindResourceTypeByPathStub != nil {
		return fake.FindResourceTypeByPathStub(path)
	} else {
		return fake.findResourceTypeByPathReturns.result1, fake.findResourceTypeByPathReturns.result2
	}
}

func (fake *FakeWorker) FindResourceTypeByPathCallCount() int {
	fake.findResourceTypeByPathMutex.RLock()
	defer fake.findResourceTypeByPathMutex.RUnlock()
	return len(fake.findResourceTypeByPathArgsForCall)
}

func (fake *FakeWorker) FindResourceTypeByPathArgsForCall(i int) string {
	fake.findResourceTypeByPathMutex.RLock()
	defer fake.findResourceTypeByPathMutex.RUnlock()
	return fake.findResourceTypeByPathArgsForCall[i].path
}

func (fake *FakeWorker) FindResourceTypeByPathReturns(result1 atc.WorkerResourceType, result2 bool) {
	fake.FindResourceTypeByPathStub = nil
	fake.findResourceTypeByPathReturns = struct {
		result1 atc.WorkerResourceType
		result2 bool
	}{result1, result2}
}

func (fake *FakeWorker) LookupVolume(arg1 lager.Logger, arg2 string) (worker.Volume, bool, error) {
	fake.lookupVolumeMutex.Lock()
	fake.lookupVolumeArgsForCall = append(fake.lookupVolumeArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("LookupVolume", []interface{}{arg1, arg2})
	fake.lookupVolumeMutex.Unlock()
	if fake.LookupVolumeStub != nil {
		return fake.LookupVolumeStub(arg1, arg2)
	} else {
		return fake.lookupVolumeReturns.result1, fake.lookupVolumeReturns.result2, fake.lookupVolumeReturns.result3
	}
}

func (fake *FakeWorker) LookupVolumeCallCount() int {
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	return len(fake.lookupVolumeArgsForCall)
}

func (fake *FakeWorker) LookupVolumeArgsForCall(i int) (lager.Logger, string) {
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	return fake.lookupVolumeArgsForCall[i].arg1, fake.lookupVolumeArgsForCall[i].arg2
}

func (fake *FakeWorker) LookupVolumeReturns(result1 worker.Volume, result2 bool, result3 error) {
	fake.LookupVolumeStub = nil
	fake.lookupVolumeReturns = struct {
		result1 worker.Volume
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) Satisfying(arg1 worker.WorkerSpec, arg2 atc.ResourceTypes) (worker.Worker, error) {
	fake.satisfyingMutex.Lock()
	fake.satisfyingArgsForCall = append(fake.satisfyingArgsForCall, struct {
		arg1 worker.WorkerSpec
		arg2 atc.ResourceTypes
	}{arg1, arg2})
	fake.recordInvocation("Satisfying", []interface{}{arg1, arg2})
	fake.satisfyingMutex.Unlock()
	if fake.SatisfyingStub != nil {
		return fake.SatisfyingStub(arg1, arg2)
	} else {
		return fake.satisfyingReturns.result1, fake.satisfyingReturns.result2
	}
}

func (fake *FakeWorker) SatisfyingCallCount() int {
	fake.satisfyingMutex.RLock()
	defer fake.satisfyingMutex.RUnlock()
	return len(fake.satisfyingArgsForCall)
}

func (fake *FakeWorker) SatisfyingArgsForCall(i int) (worker.WorkerSpec, atc.ResourceTypes) {
	fake.satisfyingMutex.RLock()
	defer fake.satisfyingMutex.RUnlock()
	return fake.satisfyingArgsForCall[i].arg1, fake.satisfyingArgsForCall[i].arg2
}

func (fake *FakeWorker) SatisfyingReturns(result1 worker.Worker, result2 error) {
	fake.SatisfyingStub = nil
	fake.satisfyingReturns = struct {
		result1 worker.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) AllSatisfying(arg1 worker.WorkerSpec, arg2 atc.ResourceTypes) ([]worker.Worker, error) {
	fake.allSatisfyingMutex.Lock()
	fake.allSatisfyingArgsForCall = append(fake.allSatisfyingArgsForCall, struct {
		arg1 worker.WorkerSpec
		arg2 atc.ResourceTypes
	}{arg1, arg2})
	fake.recordInvocation("AllSatisfying", []interface{}{arg1, arg2})
	fake.allSatisfyingMutex.Unlock()
	if fake.AllSatisfyingStub != nil {
		return fake.AllSatisfyingStub(arg1, arg2)
	} else {
		return fake.allSatisfyingReturns.result1, fake.allSatisfyingReturns.result2
	}
}

func (fake *FakeWorker) AllSatisfyingCallCount() int {
	fake.allSatisfyingMutex.RLock()
	defer fake.allSatisfyingMutex.RUnlock()
	return len(fake.allSatisfyingArgsForCall)
}

func (fake *FakeWorker) AllSatisfyingArgsForCall(i int) (worker.WorkerSpec, atc.ResourceTypes) {
	fake.allSatisfyingMutex.RLock()
	defer fake.allSatisfyingMutex.RUnlock()
	return fake.allSatisfyingArgsForCall[i].arg1, fake.allSatisfyingArgsForCall[i].arg2
}

func (fake *FakeWorker) AllSatisfyingReturns(result1 []worker.Worker, result2 error) {
	fake.AllSatisfyingStub = nil
	fake.allSatisfyingReturns = struct {
		result1 []worker.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) RunningWorkers() ([]worker.Worker, error) {
	fake.runningWorkersMutex.Lock()
	fake.runningWorkersArgsForCall = append(fake.runningWorkersArgsForCall, struct{}{})
	fake.recordInvocation("RunningWorkers", []interface{}{})
	fake.runningWorkersMutex.Unlock()
	if fake.RunningWorkersStub != nil {
		return fake.RunningWorkersStub()
	} else {
		return fake.runningWorkersReturns.result1, fake.runningWorkersReturns.result2
	}
}

func (fake *FakeWorker) RunningWorkersCallCount() int {
	fake.runningWorkersMutex.RLock()
	defer fake.runningWorkersMutex.RUnlock()
	return len(fake.runningWorkersArgsForCall)
}

func (fake *FakeWorker) RunningWorkersReturns(result1 []worker.Worker, result2 error) {
	fake.RunningWorkersStub = nil
	fake.runningWorkersReturns = struct {
		result1 []worker.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) GetWorker(workerName string) (worker.Worker, error) {
	fake.getWorkerMutex.Lock()
	fake.getWorkerArgsForCall = append(fake.getWorkerArgsForCall, struct {
		workerName string
	}{workerName})
	fake.recordInvocation("GetWorker", []interface{}{workerName})
	fake.getWorkerMutex.Unlock()
	if fake.GetWorkerStub != nil {
		return fake.GetWorkerStub(workerName)
	} else {
		return fake.getWorkerReturns.result1, fake.getWorkerReturns.result2
	}
}

func (fake *FakeWorker) GetWorkerCallCount() int {
	fake.getWorkerMutex.RLock()
	defer fake.getWorkerMutex.RUnlock()
	return len(fake.getWorkerArgsForCall)
}

func (fake *FakeWorker) GetWorkerArgsForCall(i int) string {
	fake.getWorkerMutex.RLock()
	defer fake.getWorkerMutex.RUnlock()
	return fake.getWorkerArgsForCall[i].workerName
}

func (fake *FakeWorker) GetWorkerReturns(result1 worker.Worker, result2 error) {
	fake.GetWorkerStub = nil
	fake.getWorkerReturns = struct {
		result1 worker.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ActiveContainers() int {
	fake.activeContainersMutex.Lock()
	fake.activeContainersArgsForCall = append(fake.activeContainersArgsForCall, struct{}{})
	fake.recordInvocation("ActiveContainers", []interface{}{})
	fake.activeContainersMutex.Unlock()
	if fake.ActiveContainersStub != nil {
		return fake.ActiveContainersStub()
	} else {
		return fake.activeContainersReturns.result1
	}
}

func (fake *FakeWorker) ActiveContainersCallCount() int {
	fake.activeContainersMutex.RLock()
	defer fake.activeContainersMutex.RUnlock()
	return len(fake.activeContainersArgsForCall)
}

func (fake *FakeWorker) ActiveContainersReturns(result1 int) {
	fake.ActiveContainersStub = nil
	fake.activeContainersReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) Description() string {
	fake.descriptionMutex.Lock()
	fake.descriptionArgsForCall = append(fake.descriptionArgsForCall, struct{}{})
	fake.recordInvocation("Description", []interface{}{})
	fake.descriptionMutex.Unlock()
	if fake.DescriptionStub != nil {
		return fake.DescriptionStub()
	} else {
		return fake.descriptionReturns.result1
	}
}

func (fake *FakeWorker) DescriptionCallCount() int {
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	return len(fake.descriptionArgsForCall)
}

func (fake *FakeWorker) DescriptionReturns(result1 string) {
	fake.DescriptionStub = nil
	fake.descriptionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Name() string {
	fake.nameMutex.Lock()
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	} else {
		return fake.nameReturns.result1
	}
}

func (fake *FakeWorker) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeWorker) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Address() *string {
	fake.addressMutex.Lock()
	fake.addressArgsForCall = append(fake.addressArgsForCall, struct{}{})
	fake.recordInvocation("Address", []interface{}{})
	fake.addressMutex.Unlock()
	if fake.AddressStub != nil {
		return fake.AddressStub()
	} else {
		return fake.addressReturns.result1
	}
}

func (fake *FakeWorker) AddressCallCount() int {
	fake.addressMutex.RLock()
	defer fake.addressMutex.RUnlock()
	return len(fake.addressArgsForCall)
}

func (fake *FakeWorker) AddressReturns(result1 *string) {
	fake.AddressStub = nil
	fake.addressReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) ResourceTypes() []atc.WorkerResourceType {
	fake.resourceTypesMutex.Lock()
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct{}{})
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if fake.ResourceTypesStub != nil {
		return fake.ResourceTypesStub()
	} else {
		return fake.resourceTypesReturns.result1
	}
}

func (fake *FakeWorker) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakeWorker) ResourceTypesReturns(result1 []atc.WorkerResourceType) {
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) Tags() atc.Tags {
	fake.tagsMutex.Lock()
	fake.tagsArgsForCall = append(fake.tagsArgsForCall, struct{}{})
	fake.recordInvocation("Tags", []interface{}{})
	fake.tagsMutex.Unlock()
	if fake.TagsStub != nil {
		return fake.TagsStub()
	} else {
		return fake.tagsReturns.result1
	}
}

func (fake *FakeWorker) TagsCallCount() int {
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	return len(fake.tagsArgsForCall)
}

func (fake *FakeWorker) TagsReturns(result1 atc.Tags) {
	fake.TagsStub = nil
	fake.tagsReturns = struct {
		result1 atc.Tags
	}{result1}
}

func (fake *FakeWorker) Uptime() time.Duration {
	fake.uptimeMutex.Lock()
	fake.uptimeArgsForCall = append(fake.uptimeArgsForCall, struct{}{})
	fake.recordInvocation("Uptime", []interface{}{})
	fake.uptimeMutex.Unlock()
	if fake.UptimeStub != nil {
		return fake.UptimeStub()
	} else {
		return fake.uptimeReturns.result1
	}
}

func (fake *FakeWorker) UptimeCallCount() int {
	fake.uptimeMutex.RLock()
	defer fake.uptimeMutex.RUnlock()
	return len(fake.uptimeArgsForCall)
}

func (fake *FakeWorker) UptimeReturns(result1 time.Duration) {
	fake.UptimeStub = nil
	fake.uptimeReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeWorker) IsOwnedByTeam() bool {
	fake.isOwnedByTeamMutex.Lock()
	fake.isOwnedByTeamArgsForCall = append(fake.isOwnedByTeamArgsForCall, struct{}{})
	fake.recordInvocation("IsOwnedByTeam", []interface{}{})
	fake.isOwnedByTeamMutex.Unlock()
	if fake.IsOwnedByTeamStub != nil {
		return fake.IsOwnedByTeamStub()
	} else {
		return fake.isOwnedByTeamReturns.result1
	}
}

func (fake *FakeWorker) IsOwnedByTeamCallCount() int {
	fake.isOwnedByTeamMutex.RLock()
	defer fake.isOwnedByTeamMutex.RUnlock()
	return len(fake.isOwnedByTeamArgsForCall)
}

func (fake *FakeWorker) IsOwnedByTeamReturns(result1 bool) {
	fake.IsOwnedByTeamStub = nil
	fake.isOwnedByTeamReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) IsVersionCompatible() bool {
	fake.isVersionCompatibleMutex.Lock()
	fake.isVersionCompatibleArgsForCall = append(fake.isVersionCompatibleArgsForCall, struct{}{})
	fake.recordInvocation("IsVersionCompatible", []interface{}{})
	fake.isVersionCompatibleMutex.Unlock()
	if fake.IsVersionCompatibleStub != nil {
		return fake.IsVersionCompatibleStub()
	} else {
		return fake.isVersionCompatibleReturns.result1
	}
}

func (fake *FakeWorker) IsVersionCompatibleCallCount() int {
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	return len(fake.isVersionCompatibleArgsForCall)
}

func (fake *FakeWorker) IsVersionCompatibleReturns(result1 bool) {
	fake.IsVersionCompatibleStub = nil
	fake.isVersionCompatibleReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.findOrCreateBuildContainerMutex.RLock()
	defer fake.findOrCreateBuildContainerMutex.RUnlock()
	fake.findOrCreateResourceGetContainerMutex.RLock()
	defer fake.findOrCreateResourceGetContainerMutex.RUnlock()
	fake.findOrCreateResourceCheckContainerMutex.RLock()
	defer fake.findOrCreateResourceCheckContainerMutex.RUnlock()
	fake.findOrCreateResourceTypeCheckContainerMutex.RLock()
	defer fake.findOrCreateResourceTypeCheckContainerMutex.RUnlock()
	fake.findOrCreateContainerForIdentifierMutex.RLock()
	defer fake.findOrCreateContainerForIdentifierMutex.RUnlock()
	fake.findOrCreateVolumeForResourceCacheMutex.RLock()
	defer fake.findOrCreateVolumeForResourceCacheMutex.RUnlock()
	fake.findInitializedVolumeForResourceCacheMutex.RLock()
	defer fake.findInitializedVolumeForResourceCacheMutex.RUnlock()
	fake.findContainerForIdentifierMutex.RLock()
	defer fake.findContainerForIdentifierMutex.RUnlock()
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	fake.validateResourceCheckVersionMutex.RLock()
	defer fake.validateResourceCheckVersionMutex.RUnlock()
	fake.findResourceTypeByPathMutex.RLock()
	defer fake.findResourceTypeByPathMutex.RUnlock()
	fake.lookupVolumeMutex.RLock()
	defer fake.lookupVolumeMutex.RUnlock()
	fake.satisfyingMutex.RLock()
	defer fake.satisfyingMutex.RUnlock()
	fake.allSatisfyingMutex.RLock()
	defer fake.allSatisfyingMutex.RUnlock()
	fake.runningWorkersMutex.RLock()
	defer fake.runningWorkersMutex.RUnlock()
	fake.getWorkerMutex.RLock()
	defer fake.getWorkerMutex.RUnlock()
	fake.activeContainersMutex.RLock()
	defer fake.activeContainersMutex.RUnlock()
	fake.descriptionMutex.RLock()
	defer fake.descriptionMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.addressMutex.RLock()
	defer fake.addressMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	fake.uptimeMutex.RLock()
	defer fake.uptimeMutex.RUnlock()
	fake.isOwnedByTeamMutex.RLock()
	defer fake.isOwnedByTeamMutex.RUnlock()
	fake.isVersionCompatibleMutex.RLock()
	defer fake.isVersionCompatibleMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeWorker) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ worker.Worker = new(FakeWorker)
